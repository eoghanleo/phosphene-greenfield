# FYI — Signal design ideas (non-authoritative)

This file is **FYI only**.

**Source of truth:** PHOSPHENE signals are generated by **scripts** into the central bus:

- `phosphene/signals/**`

This document exists purely to preserve a few useful design ideas that can inform future script implementations and GitHub automation.

## Current build alignment (high-signal notes)

- Signals are **repo-native, append-only telemetry + orchestration hints**.
- Signals are **not hand-written**; they are emitted by scripts.
- **Issue mutation policy**: only **autoscribes** may create/update Issues. Other instruments may comment.
- Signal consumption for the research → product-marketing handoff is implemented as an **autoscribe** that runs on PR merge:
  - `gantry.autoscribe.product-marketing`

## Active signals (append-only indexes; no repo scans)

The monotonic DAG rule (“consumed if referenced by a child signal”) can be implemented without scanning every JSON signal file by maintaining two append-only TSV indexes:

- `phosphene/signals/indexes/signals_index.tsv`
  - appended once per newly created signal
- `phosphene/signals/indexes/parent_signals_index.tsv`
  - appended once per unique parent `signal_id` referenced by any newly created signal (deduplicated)

### Why two indexes

If we define:

- \(S\) = set of all `signal_id`s in `signals_index.tsv`
- \(P\) = set of all `signal_id`s in `parent_signals_index.tsv`

Then the “active” (unconsumed) signals are:

\[
S \setminus P
\]

This is:
- **append-only**
- **immutable (monotonic)**: once a signal id appears in \(P\), it is considered consumed forever
- cheap for gantries: read two files, compute a set difference

### Index formats (v1; script-owned)

These are intentionally simple so they can be maintained with bash-only tooling.

`phosphene/signals/indexes/signals_index.tsv` (append-only; never edit existing lines):

- `signal_id<TAB>signal_path<TAB>signal_type<TAB>created_utc`

`phosphene/signals/indexes/parent_signals_index.tsv` (append-only, deduplicated by script before append):

- `parent_signal_id`

Notes:
- Lines beginning with `#` are comments and should be ignored by scripts/gantries.
- Scripts should ensure parents are **normalized** (e.g., sorted in the JSON) but the index itself only needs the parent ids.
- Detectors can enforce “append-only” by rejecting diffs that modify existing lines in these TSV files.

## Handoff signals: research → product-marketing (idea bundle)

### Where it lives

- `phosphene/signals/**`

### When it is consumed

On **PR merge** (not PR open) that includes one or more matching signal files.

### Monotonic consumption rule (no mutation)

Signals are **append-only**. The system should not “retire” a signal by editing or moving it.

Instead, a signal can be considered **consumed** when it has one or more **child signals** (i.e., any other signal declares it in `parents[]`).

This keeps the state machine monotonic: GitHub Actions can decide what to do next by looking only at the signals present in the repo.

### ID scheme (hash-DAG)

Signal identifiers can be made **hash-derived** for stability and collision resistance.

- Use **SHA-256** (not MD5).

Implemented helper (canonical for v1 IDs):

- `phosphene/phosphene-core/bin/signal_hash.sh`

Recommended fields:

- `parents[]`: array of parent `signal_id`s (often 0 or 1)
- `run_marker`: stable marker from the run that emitted the signal (e.g. `RA-001`, `FR-012`, or a run slug)
- `output_key`: per-signal discriminator unique within the run (required once a run can emit multiple signals)

Computation idea (v1):

- Sort `parents` lexicographically
- Hash a domain-separated preimage:

\[
\texttt{parents\_root} = \texttt{sha256}("phosphene/parents/v1\\n" + join(sorted(parents), "\\n"))
\]

Then compute:

\[
\texttt{signal\_id} = \texttt{sha256}("phosphene/signal/v1\\n" + parents\_root + "\\n" + run\_marker + "\\n" + output\_key)
\]

Represent IDs as:

- `sha256:<hex>`

Multi-output runs:

If a run emits multiple signals, do not reuse `output_key`. Example patterns:

- `handoff:research->product-marketing`
- `handoff:research->product-marketing:persona:CPE-0002`
- `handoff:research->product-marketing:prop:PROP-0007`

### Example signal shape (v1; minimal; for scripts to emit)

```json
{
  "signal_version": 1,
  "signal_id": "sha256:<hex>",
  "signal_type": "phosphene.handoff.research_to_product_marketing.v1",
  "from_domain": "research",
  "to_domain": "product-marketing",
  "work_id": "RA-001",
  "intent": "proposition-development",
  "parents": [],
  "run_marker": "RA-001",
  "output_key": "handoff:research->product-marketing",
  "created_utc": "2026-01-15T00:00:00Z"
}
```

Optional fields idea (v1):

- `origin`: provenance metadata
- `title`: override for downstream issue title suffix
- `labels`: additional labels for downstream issue creation
- `notes`: short human-readable context for downstream issue body

