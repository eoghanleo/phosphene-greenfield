name: "gantry.autoscribe.issue-adopt"

on:
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      mode:
        description: "help: comment usage; tidy: normalize issue only; adopt: tidy + emit autoscribe issue_created signal to bus"
        required: true
        type: choice
        options: ["help", "tidy", "adopt"]
        default: "tidy"
      domain:
        description: "Target domain to enforce (sets color label + work_type + labels)"
        required: true
        type: choice
        options:
          - "research"
          - "product-marketing"
          - "product-management"
          - "ideation"
          - "product-vision"
          - "product-strategy"
          - "product-architecture"
          - "product-evaluation"
          - "feature-management"
          - "test-management"
          - "scrum-management"
      issue_number:
        description: "Issue number to tidy/adopt"
        required: true
        type: number
      work_id:
        description: "Work ID to set in [PHOSPHENE] block (optional; will attempt to infer/allocate)"
        required: false
        type: string
        default: ""
      intent:
        description: "Intent string to set in [PHOSPHENE] block (optional)"
        required: false
        type: string
        default: ""
      upstream_signal_id:
        description: "Optional upstream signal_id (sha256:...) to embed as upstream_signal_id"
        required: false
        type: string
        default: ""

permissions:
  actions: write
  issues: write
  contents: write

env:
  # Gantry write boundary: signal bus only.
  PHOSPHENE_GANTRY_WRITE_ALLOWLIST: |
    phosphene/signals/**
    phosphene/signals/indexes/**
  PHOSPHENE_HUMAN_TOKEN: ${{ secrets.PHOSPHENE_HUMAN_TOKEN }}

concurrency:
  group: instrument-autoscribe-issue-adopt-${{ inputs.issue_number || github.run_id }}
  cancel-in-progress: true

jobs:
  tidy_and_optionally_adopt:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v5
        with:
          ref: main
          fetch-depth: 0
          persist-credentials: false

      - name: Tidy issue into strict [PHOSPHENE] (and optionally emit bus signal)
        id: tidy
        uses: actions/github-script@v7
        with:
          script: |
            const { execFileSync } = require("child_process");
            const fs = require("fs");
            const { owner, repo } = context.repo;

            const eventName = String(context.eventName || "");

            // --- command parsing helpers (issue_comment mode) ---
            const stripTicks = (s) => String(s || "").trim().replace(/^`+|`+$/g, "");
            const parseFlag = (text, name) => {
              const t = String(text || "");
              const re1 = new RegExp(`(?:^|\\s)--${name}\\s+\\"([^\\"]*)\\"`);
              const re2 = new RegExp(`(?:^|\\s)--${name}\\s+'([^']*)'`);
              const re3 = new RegExp(`(?:^|\\s)--${name}\\s+([^\\s]+)`);
              let m = t.match(re1); if (m) return stripTicks(m[1]);
              m = t.match(re2); if (m) return stripTicks(m[1]);
              m = t.match(re3); if (m) return stripTicks(m[1]);
              return "";
            };
            const pickCommandLine = (commentBody) => {
              const lines = String(commentBody || "").split(/\r?\n/);
              for (const line of lines) {
                const l = String(line || "").trim();
                if (!l) continue;
                if (l.startsWith("/phosphene autoscribe")) return l;
                if (l.startsWith("@phosphene autoscribe")) return l;
                // tolerate extra prefix words
                if (/\b\/phosphene\s+autoscribe\b/.test(l)) return l.slice(l.indexOf("/phosphene"));
                if (/\b@phosphene\s+autoscribe\b/.test(l)) return l.slice(l.indexOf("@phosphene"));
              }
              return "";
            };

            // Resolve inputs either from workflow_dispatch or issue_comment command.
            let mode = "";
            let domain = "";
            let issue_number = 0;
            let workIdInput = "";
            let intentInput = "";
            let upstreamSignalIdInput = "";

            if (eventName === "workflow_dispatch") {
              mode = String(core.getInput("mode", { required: true }) || "").trim();
              domain = String(core.getInput("domain", { required: true }) || "").trim();
              issue_number = Number(core.getInput("issue_number", { required: true }) || 0);
              workIdInput = String(core.getInput("work_id") || "").trim();
              intentInput = String(core.getInput("intent") || "").trim();
              upstreamSignalIdInput = String(core.getInput("upstream_signal_id") || "").trim();
            } else if (eventName === "issue_comment") {
              const isBot = (u) => {
                const login = String(u?.login || "").toLowerCase();
                return Boolean(u?.type === "Bot" || login.endsWith("[bot]") || login === "github-actions");
              };
              if (isBot(context.payload?.comment?.user)) {
                core.notice("PHOSPHENE: ignoring autoscribe command from bot user.");
                core.setOutput("did_append", "0");
                return;
              }

              const assoc = String(context.payload?.comment?.author_association || "").toUpperCase();
              const allowed = new Set(["OWNER", "MEMBER", "COLLABORATOR"]);
              if (!allowed.has(assoc)) {
                core.notice(`PHOSPHENE: ignoring autoscribe command from non-member association: ${assoc || "(unknown)"}`);
                core.setOutput("did_append", "0");
                return;
              }

              const issue = context.payload?.issue;
              if (!issue?.number) {
                core.notice("PHOSPHENE: issue_comment event missing issue.number; no-op.");
                core.setOutput("did_append", "0");
                return;
              }
              if (issue.pull_request) {
                core.notice("PHOSPHENE: ignoring autoscribe command on PR comments (issue_comment on PR).");
                core.setOutput("did_append", "0");
                return;
              }

              issue_number = Number(issue.number || 0);
              const cmdLine = pickCommandLine(context.payload?.comment?.body || "");
              if (!cmdLine) {
                core.notice("PHOSPHENE: no autoscribe command found in comment; no-op.");
                core.setOutput("did_append", "0");
                return;
              }

              // command shape:
              //   /phosphene autoscribe <help|tidy|adopt> --domain <d> [--work-id ...] [--intent "..."] [--upstream-signal-id sha256:...]
              const after = cmdLine.replace(/^(@phosphene|\/phosphene)\s+autoscribe\s+/i, "").trim();
              const action = (after.split(/\s+/)[0] || "").trim().toLowerCase();
              if (!["help", "tidy", "adopt"].includes(action)) {
                await github.rest.issues.createComment({
                  owner, repo, issue_number,
                  body: [
                    "PHOSPHENE AUTOSCRIBE: unknown command.",
                    "",
                    "Try:",
                    "- `/phosphene autoscribe help --domain <domain>`",
                    "- `/phosphene autoscribe tidy --domain <domain> --work-id <ID>`",
                    "- `/phosphene autoscribe adopt --domain <domain> --work-id <ID>`",
                  ].join("\n"),
                });
                core.setOutput("did_append", "0");
                return;
              }
              mode = action;
              domain = parseFlag(after, "domain");
              workIdInput = parseFlag(after, "work-id");
              intentInput = parseFlag(after, "intent");
              upstreamSignalIdInput = parseFlag(after, "upstream-signal-id");

              // Fallback: infer domain from labels if not provided.
              if (!domain) {
                const labels = (issue.labels || []).map((l) => (typeof l === "string" ? l : l?.name)).filter(Boolean).map((s) => String(s));
                for (const lab of labels) {
                  const m = String(lab).match(/^phosphene:domain:(.+)$/i);
                  if (m) { domain = String(m[1] || "").trim(); break; }
                }
              }

              // Ack quickly to make the UX feel like a "summon".
              await github.rest.issues.createComment({
                owner, repo, issue_number,
                body: [
                  "PHOSPHENE AUTOSCRIBE: command received; processing now.",
                  "",
                  `- mode: \`${mode}\``,
                  `- domain: \`${domain || "(missing)"}\``,
                  workIdInput ? `- work_id (requested): \`${workIdInput}\`` : "- work_id (requested): (n/a)",
                  "",
                  "_Security_: commands are accepted only from repo members/collaborators.",
                ].join("\n"),
              });
            } else {
              core.notice(`PHOSPHENE: unsupported event ${eventName}; no-op.`);
              core.setOutput("did_append", "0");
              return;
            }

            if (!issue_number) throw new Error("Missing/invalid issue_number");
            if (!domain) {
              await github.rest.issues.createComment({
                owner, repo, issue_number,
                body: [
                  "PHOSPHENE AUTOSCRIBE: missing domain.",
                  "",
                  "Provide it explicitly:",
                  "- `/phosphene autoscribe tidy --domain product-marketing --work-id RA-001`",
                  "",
                  "Or add a label:",
                  "- `phosphene:domain:<domain>`",
                ].join("\n"),
              });
              core.setOutput("did_append", "0");
              return;
            }

            const domainMap = {
              "research": { lane: "viridian", work_type: "research", default_intent: "research-assessment", alloc_type: "ra" },
              "ideation": { lane: "viridian", work_type: "ideation", default_intent: "idea-development", alloc_type: "idea" },

              "product-marketing": { lane: "beryl", work_type: "product-marketing", default_intent: "proposition-development", alloc_type: "ra" },
              "product-vision": { lane: "beryl", work_type: "product-vision", default_intent: "vision-development", alloc_type: "vision" },
              "product-strategy": { lane: "beryl", work_type: "product-strategy", default_intent: "roadmap-development", alloc_type: "roadmap" },

              "product-management": { lane: "cerulean", work_type: "product-management", default_intent: "prd-development", alloc_type: "prd" },
              "product-architecture": { lane: "cerulean", work_type: "product-architecture", default_intent: "architecture-development", alloc_type: "arch" },
              "feature-management": { lane: "cerulean", work_type: "feature-management", default_intent: "feature-request", alloc_type: "fr" },

              "test-management": { lane: "cadmium", work_type: "test-management", default_intent: "test-plan", alloc_type: "tp" },
              "product-evaluation": { lane: "cadmium", work_type: "product-evaluation", default_intent: "evaluation", alloc_type: "eval" },

              "scrum-management": { lane: "amaranth", work_type: "scrum-management", default_intent: "issue-mirror", alloc_type: "" },
            };

            const dm = domainMap[domain];
            if (!dm) throw new Error(`Unsupported domain: ${domain}`);

            const PH_OPEN = "[PHOSPHENE]";
            const PH_CLOSE = "[/PHOSPHENE]";

            const extractBlock = (text) => {
              const openIdx = text.indexOf(PH_OPEN);
              if (openIdx === -1) return null;
              const closeIdx = text.indexOf(PH_CLOSE, openIdx);
              if (closeIdx === -1) return null;
              return {
                openIdx,
                endIdx: closeIdx + PH_CLOSE.length,
                raw: text.slice(openIdx, closeIdx + PH_CLOSE.length),
              };
            };

            const parseKvFromBlock = (rawBlock) => {
              const kv = {};
              const lines = String(rawBlock || "").split(/\r?\n/);
              for (const line of lines) {
                if (!line.includes(":")) continue;
                if (line.trim() === PH_OPEN || line.trim() === PH_CLOSE) continue;
                const m = line.match(/^\s*([a-zA-Z_]+)\s*:\s*(.*?)\s*$/);
                if (!m) continue;
                kv[String(m[1] || "").toLowerCase()] = String(m[2] || "").trim();
              }
              return kv;
            };

            const firstMatch = (s, re) => {
              const m = String(s || "").match(re);
              return m ? String(m[0] || "") : "";
            };

            const inferWorkIdFromText = (text) => {
              const t = String(text || "");
              // Prefer domain-specific patterns, then fallback to "any known PHOSPHENE-ish ID".
              const perDomain = {
                "research": /RA-[0-9]{3}/,
                "product-marketing": /RA-[0-9]{3}/,
                "product-management": /PRD-[0-9]{3}/,
                "ideation": /IDEA-[0-9]{4}/,
                "product-vision": /VISION-[0-9]{3}/,
                "product-strategy": /ROADMAP-[0-9]{3}/,
                "product-architecture": /ARCH-[0-9]{3}/,
                "product-evaluation": /EVAL-[0-9]{3}/,
                "feature-management": /FR-[0-9]{3}/,
                "test-management": /TP-[0-9]{3}/,
                "scrum-management": /ISSUE-[0-9]{3,}/,
              };
              const re = perDomain[domain] || /(RA|PRD|IDEA|VISION|ROADMAP|ARCH|EVAL|FR|TP|ISSUE)-[0-9]{3,4}/;
              return firstMatch(t, re);
            };

            const allocateNextIfPossible = () => {
              const t = String(dm.alloc_type || "").trim();
              if (!t) return "";
              try {
                const out = String(execFileSync("bash", [
                  "phosphene/phosphene-core/bin/phosphene",
                  "id",
                  "next",
                  "--type",
                  t,
                ], { encoding: "utf8" }) || "").trim();
                return out;
              } catch {
                return "";
              }
            };

            const canonicalStrictBlock = ({ lane, work_type, work_id, intent, depends_on, sequence, upstream_signal_id }) => {
              return [
                PH_OPEN,
                `lane: ${lane}`,
                `work_type: ${work_type}`,
                `work_id: ${work_id}`,
                `intent: ${intent}`,
                `depends_on: ${depends_on || ""}`.trimEnd(),
                `sequence: ${sequence || ""}`.trimEnd(),
                `upstream_signal_id: ${upstream_signal_id || ""}`.trimEnd(),
                PH_CLOSE,
              ].join("\n");
            };

            const postHelp = async () => {
              const body = [
                "PHOSPHENE AUTOSCRIBE (manual issue tidy/adopt)",
                "",
                "This workflow can normalize a human-made issue into a strict `[PHOSPHENE]` block, add the correct labels, and (optionally) emit the matching `phosphene.autoscribe.<domain>.issue_created.v1` bus signal so hoppers can pick it up.",
                "",
                "## How to use",
                "### In an issue comment (recommended)",
                "- `@phosphene autoscribe help --domain <domain>`",
                "- `@phosphene autoscribe tidy --domain <domain> --work-id <ID>`",
                "- `@phosphene autoscribe adopt --domain <domain> --work-id <ID>`",
                "",
                "Also supported:",
                "- `/phosphene autoscribe ...`",
                "",
                "### Via Actions (workflow_dispatch)",
                `- workflow: \`gantry.autoscribe.issue-adopt\``,
                `- mode: \`tidy\` or \`adopt\``,
                `- domain: \`${domain}\``,
                `- issue_number: \`${issue_number}\``,
                "",
                "## Notes",
                "- `tidy` updates the issue only (no bus write).",
                "- `adopt` tidies the issue AND appends an autoscribe `issue_created` signal to `phosphene/signals/bus.jsonl` on `main` (requires `PHOSPHENE_HUMAN_TOKEN`).",
                "",
                "## CLI (local)",
                "- `./phosphene/phosphene-core/bin/phosphene autoscribe issue adopt --domain <domain> --issue-number <N>`",
                "- `./phosphene/phosphene-core/bin/phosphene autoscribe issue tidy  --domain <domain> --issue-number <N>`",
              ].join("\n");
              await github.rest.issues.createComment({ owner, repo, issue_number, body });
            };

            if (mode === "help") {
              await postHelp();
              core.setOutput("did_append", "0");
              return;
            }

            const resp = await github.rest.issues.get({ owner, repo, issue_number });
            const issue = resp.data;
            const title = String(issue?.title || "").trim();
            const body = String(issue?.body || "");
            const existingLabels = (issue.labels || [])
              .map((l) => (typeof l === "string" ? l : l?.name))
              .filter(Boolean)
              .map((s) => String(s));

            const block = extractBlock(body);
            const kv = block ? parseKvFromBlock(block.raw) : {};

            let work_id = workIdInput
              || String(kv.work_id || "").trim()
              || inferWorkIdFromText(title)
              || inferWorkIdFromText(body);
            if (!work_id) {
              work_id = allocateNextIfPossible();
            }

            const intent = intentInput || String(kv.intent || "").trim() || title || dm.default_intent;
            const upstream_signal_id = upstreamSignalIdInput || String(kv.upstream_signal_id || "").trim();

            const strictBlock = canonicalStrictBlock({
              lane: dm.lane,
              work_type: dm.work_type,
              work_id,
              intent,
              depends_on: "",
              sequence: "",
              upstream_signal_id,
            });

            // Compose updated issue body: replace existing [PHOSPHENE] block if present, else prepend.
            const rest = block ? (body.slice(0, block.openIdx) + body.slice(block.endIdx)).trim() : body.trim();
            let updatedBody = [strictBlock, "", rest].join("\n").trim() + "\n";

            // For ideation, hydrate the canonical prompt template so the issue matches autoscribe output.
            const templatePath = ".github/prompts/domain_delegation_prompt.md";
            const canHydrate = (domain === "ideation") && fs.existsSync(templatePath);
            const hasTemplateMarker = rest.includes("PHOSPHENE — Domain Delegation Prompt (parameterized)")
              || rest.includes("SYSTEM: You are a Codex agent operating inside a PHOSPHENE harness repo.");
            if (canHydrate && !hasTemplateMarker) {
              const upstreamDomainTag = "<manual>";
              const domainTag = `<${domain}>`;
              const domainSkillPath = ".codex/skills/phosphene/viridian/ideation/modulator/SKILL.md";
              const domainScriptsPath = ".codex/skills/phosphene/viridian/ideation/modulator/scripts/";
              const AXES_REGISTRY_PATH = "phosphene/domains/ideation/reference/creative_exploration_axes.tsv";
              const AXES_OPEN = "[PHOSPHENE_IDEATION_AXES]";
              const AXES_CLOSE = "[/PHOSPHENE_IDEATION_AXES]";

              const extractAxesBlock = (text) => {
                const t = String(text || "");
                const idx = t.indexOf(AXES_OPEN);
                if (idx === -1) return null;
                const end = t.indexOf(AXES_CLOSE, idx + AXES_OPEN.length);
                if (end === -1) return null;
                const block = t.slice(idx, end + AXES_CLOSE.length);
                const ids = [];
                const inner = t.slice(idx + AXES_OPEN.length, end);
                for (const rawLine of inner.split(/\r?\n/)) {
                  const line = rawLine.trim();
                  if (!line) continue;
                  const m = line.match(/(AX-[0-9]{3})/);
                  if (m) ids.push(m[1]);
                }
                return { block, ids };
              };

              const mulberry32 = (a) => () => {
                let t = (a += 0x6D2B79F5);
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
              };

              const readAxesRegistry = () => {
                if (!fs.existsSync(AXES_REGISTRY_PATH)) throw new Error(`Missing axes registry: ${AXES_REGISTRY_PATH}`);
                const raw = String(fs.readFileSync(AXES_REGISTRY_PATH, "utf8") || "").trim();
                const lines = raw.split(/\r?\n/).map((l) => l.trimEnd()).filter(Boolean);
                if (!lines.length) throw new Error(`Empty axes registry: ${AXES_REGISTRY_PATH}`);
                const out = [];
                for (let i = 0; i < lines.length; i++) {
                  const line = lines[i];
                  if (i === 0 && line.startsWith("AxisID\t")) continue;
                  const parts = line.split("\t");
                  if (parts.length < 5) continue;
                  const [id, category, axis, poles, explanation] = parts;
                  if (!/^AX-[0-9]{3}$/.test(id)) continue;
                  out.push({ id, category, axis, poles, explanation });
                }
                return out;
              };

              const sampleAxes = (allAxes, n, seed) => {
                const rng = mulberry32(Number(seed || 1));
                const arr = allAxes.slice();
                for (let i = arr.length - 1; i > 0; i--) {
                  const j = Math.floor(rng() * (i + 1));
                  const tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;
                }
                return arr.slice(0, n);
              };

              const buildAxesBlock = (selected) => ([
                AXES_OPEN,
                ...selected.map((a) => `${a.id} | ${a.category} | ${a.axis} | ${a.poles} | ${a.explanation}`),
                AXES_CLOSE,
              ].join("\n"));

              let doneScoreMin = "10";
              try {
                doneScoreMin = String(execFileSync("bash", [
                  "phosphene/phosphene-core/bin/phosphene_config.sh",
                  "get",
                  "--color",
                  dm.lane,
                  "--key",
                  `${domain}.done_score_min`,
                  "--default",
                  "10",
                ], { encoding: "utf8" }) || "10").trim();
              } catch {}
              if (!doneScoreMin) doneScoreMin = "10";
              const domainDoneScoreCmd = `./.github/scripts/ideation-domain-done-score.sh --file <IDEA_PATH> --min-score ${doneScoreMin}`;

              const pointerLines = [
                `- Manual issue: #${issue_number}`,
                work_id ? `- work_id: \`${work_id}\`` : "- work_id: (missing)",
              ];

              let axesBlockText = "";
              const existingAxes = extractAxesBlock(rest);
              if (existingAxes?.block) {
                axesBlockText = String(existingAxes.block || "").trim();
              } else {
                const allAxes = readAxesRegistry();
                const selected = sampleAxes(allAxes, 10, issue_number);
                axesBlockText = buildAxesBlock(selected);
              }

              const notesBlock = [
                "## CREATIVE EXPLORATION AXES (mandatory for this run)",
                "",
                axesBlockText,
                "",
                "### Intended behavior",
                "- Produce a single IDEA artifact that contains a **Creative exploration matrix**:",
                "  - 10 sampled axes (above) × 3 rings = **30 required rows** (every combination).",
                "  - Final column must be an **Idea paragraph (≥ 3 sentences)** per row.",
                "  - Stress-test fields must be present per row: FailureMode, ValueCore, Differentiator.",
                "- Interpret each axis as a **context infusion** (an abstract stance/persona).",
                "  - Do NOT copy the axis label/poles verbatim into the Idea paragraph unless it is a perfect fit.",
                "- Use bash scripts to update the matrix (do not hand-edit table rows).",
                "- Run validators + done-score and PASS before writing DONE receipt.",
                "",
                rest ? ["### Original issue content", "", rest].join("\n") : "",
              ].join("\n").trim();

              const template = fs.readFileSync(templatePath, "utf8");
              const hydrated = template
                .replaceAll("{{UPSTREAM_PR_NUMBER}}", "N/A")
                .replaceAll("{{UPSTREAM_PR_TITLE}}", "(manual autoscribe adopt)")
                .replaceAll("{{UPSTREAM_PR_URL}}", "(n/a)")
                .replaceAll("{{UPSTREAM_WORK_ID}}", work_id || "(unknown)")
                .replaceAll("{{SIGNAL_PATH}}", "phosphene/signals/bus.jsonl")
                .replaceAll("{{UPSTREAM_DOMAIN_TAG}}", upstreamDomainTag)
                .replaceAll("{{DOMAIN_TAG}}", domainTag)
                .replaceAll("{{DOMAIN_SKILL_PATH}}", domainSkillPath)
                .replaceAll("{{DOMAIN_SCRIPTS_PATH}}", domainScriptsPath)
                .replaceAll("{{DOMAIN_DONE_SIGNAL_PATH}}", "phosphene/signals/bus.jsonl (DONE receipt line)")
                .replaceAll("{{DONE_SCORE_MIN}}", doneScoreMin)
                .replaceAll("{{DOMAIN_DONE_SCORE_CMD}}", domainDoneScoreCmd)
                .replaceAll("{{INTENT}}", intent || dm.default_intent)
                .replaceAll("{{POINTERS_BULLETS}}", pointerLines.join("\n"))
                .replaceAll("{{NOTES_BLOCK}}", notesBlock)
                .replaceAll("{{PHOSPHENE_DEDUPE_MARKER}}", `phosphene-autoscribe:manual-issue:${issue_number}`);

              updatedBody = [strictBlock, "", hydrated].join("\n").trim() + "\n";
            } else if (canHydrate && hasTemplateMarker) {
              // Already hydrated: avoid re-embedding the template or duplicating sections.
              updatedBody = [strictBlock, "", rest].join("\n").trim() + "\n";
            }

            // Labels: always add phosphene + color + domain + instrument; add ready only in adopt mode.
            const want = new Set(existingLabels);
            want.add("phosphene");
            want.add(`phosphene:domain:${domain}`);
            want.add(`phosphene:${dm.lane}`);
            want.add("phosphene:instrument:autoscribe");
            if (mode === "adopt") want.add("phosphene:ready");

            // Apply issue updates.
            await github.rest.issues.update({
              owner,
              repo,
              issue_number,
              body: updatedBody,
              labels: Array.from(want),
            });

            const commentLines = [
              "PHOSPHENE AUTOSCRIBE: issue normalized for reintegration.",
              "",
              `- domain: \`${domain}\``,
              `- lane: \`${dm.lane}\``,
              `- work_type: \`${dm.work_type}\``,
              `- work_id: \`${work_id || "(missing)"}\``,
              `- mode: \`${mode}\``,
              "",
              "Next:",
              "- If mode was `tidy`: run hopper manual evaluation (or rerun this workflow with mode=`adopt`).",
              "- If mode was `adopt`: hoppers will see the bus append and decide eligibility (labels + strict block now in place).",
            ];

            if (!work_id) {
              commentLines.push("", "**WARNING**: work_id could not be inferred or allocated; hopper will treat this as ineligible until work_id is set.");
            }

            const busPath = "phosphene/signals/bus.jsonl";
            const output_key = `autoscribe:issue-adopted:${domain}:issue:${issue_number}`;
            let didAppend = false;
            let signal_id = "";

            if (mode === "adopt" && work_id) {
              // Compute deterministic signal_id (optionally parent upstream_signal_id if it looks like a sha256 id).
              const hashArgs = [
                "phosphene/phosphene-core/bin/signal_hash.sh",
                "signal-id",
                "--run-marker",
                work_id,
                "--output-key",
                output_key,
              ];
              if (/^sha256:[0-9A-Fa-f]{64}$/.test(upstream_signal_id)) {
                hashArgs.push("--parent", upstream_signal_id);
              }
              signal_id = String(execFileSync("bash", hashArgs, { encoding: "utf8" }) || "").trim();

              const busText = fs.existsSync(busPath) ? fs.readFileSync(busPath, "utf8") : "";
              if (!busText.includes(`"signal_id":"${signal_id}"`)) {
                const created_utc = new Date().toISOString().replace(/\.\d{3}Z$/, "Z");
                const sig = {
                  signal_version: 1,
                  signal_id,
                  signal_type: `phosphene.autoscribe.${domain}.issue_created.v1`,
                  work_id,
                  domain,
                  issue_number,
                  lane: dm.lane,
                  intent,
                  phos_id: "",
                  parents: (/^sha256:[0-9A-Fa-f]{64}$/.test(upstream_signal_id) ? [upstream_signal_id] : []),
                  run_marker: work_id,
                  output_key,
                  created_utc,
                };

                execFileSync("bash", [
                  "phosphene/phosphene-core/bin/signal_bus.sh",
                  "append",
                  "--bus",
                  busPath,
                  "--line",
                  JSON.stringify(sig),
                ], { stdio: "inherit" });

                didAppend = true;
                commentLines.push("", `- emitted: \`${sig.signal_type}\``, `- signal_id: \`${signal_id}\``);
              } else {
                commentLines.push("", `- bus: already adopted (idempotent)`, `- signal_id: \`${signal_id}\``);
              }
            }

            await github.rest.issues.createComment({ owner, repo, issue_number, body: commentLines.join("\n") });

            core.setOutput("did_append", didAppend ? "1" : "0");

      - name: Commit + push bus append (adopt mode)
        if: steps.tidy.outputs.did_append == '1'
        shell: bash
        run: |
          set -euo pipefail

          export PHOSPHENE_GANTRY_WRITE_ALLOWLIST=$'phosphene/signals/**\nphosphene/signals/indexes/**'
          bash phosphene/phosphene-core/bin/gantry_write_allowlist_guard.sh check

          if [[ -z "${PHOSPHENE_HUMAN_TOKEN:-}" ]]; then
            echo "PHOSPHENE: missing PHOSPHENE_HUMAN_TOKEN; refusing to push bus changes (would suppress downstream workflows)."
            exit 1
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git remote set-url origin "https://x-access-token:${PHOSPHENE_HUMAN_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          git add "phosphene/signals/bus.jsonl"
          git commit -m "PHOSPHENE: adopt issue #${{ inputs.issue_number }} into ${{ inputs.domain }} (autoscribe)" || exit 0
          git push origin HEAD:main

