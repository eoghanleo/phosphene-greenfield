name: "gantry.autoscribe.product-marketing"

on:
  pull_request:
    types: [closed]
    branches: [main]
    paths:
      - "phosphene/signals/bus.jsonl"
  workflow_dispatch:
    inputs:
      work_id:
        description: "Work ID (e.g., RA-001)"
        required: false
        type: string
      lane:
        description: "Lane"
        required: false
        type: choice
        options: ["beryl", "cerulean"]
        default: "cerulean"
      intent:
        description: "Intent string for the work"
        required: false
        type: string
        default: "proposition-development"
      parent_signal_id:
        description: "Parent signal_id from bus.jsonl (optional)"
        required: false
        type: string

permissions:
  contents: read
  pull-requests: read
  issues: write

env:
  # Gantry write boundary (when/if enabled): signal bus only.
  PHOSPHENE_GANTRY_WRITE_ALLOWLIST: |
    phosphene/signals/**
    phosphene/signals/indexes/**

concurrency:
  group: instrument-autoscribe-product-marketing-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: false

jobs:
  autoscribe_product_marketing_from_research_handoff:
    if: github.event_name == 'workflow_dispatch' || github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Checkout merge commit
        uses: actions/checkout@v5
        with:
          ref: ${{ github.event.pull_request.merge_commit_sha || github.sha }}
          fetch-depth: 1

      - name: Validate signal bus tamper hash (JSONL)
        shell: bash
        run: |
          set -euo pipefail
          bash phosphene/phosphene-core/bin/signal_bus.sh validate --bus phosphene/signals/bus.jsonl

      - name: Create product-marketing issue(s) from research handoff signal(s)
        uses: actions/github-script@v7
        env:
          # Optional: if set, we will post the @codex summon comment using this token
          # (so it appears authored by a human user instead of github-actions[bot]).
          PHOSPHENE_HUMAN_TOKEN: ${{ secrets.PHOSPHENE_HUMAN_TOKEN }}
        with:
          script: |
            const fs = require("fs");

            const pr = context.payload.pull_request;
            const { owner, repo } = context.repo;
            const pull_number = pr?.number || 0;

            const isDispatch = context.eventName === "workflow_dispatch";
            if (isDispatch) {
              const templatePath = ".github/prompts/domain_delegation_prompt.md";
              if (!fs.existsSync(templatePath)) {
                throw new Error(`Missing template file: ${templatePath}`);
              }
              const template = fs.readFileSync(templatePath, "utf8");

              const workIdInput = String(core.getInput("work_id") || "").trim();
              const laneInput = String(core.getInput("lane") || "").trim().toLowerCase();
              const intentInput = String(core.getInput("intent") || "").trim();
              const parentSignalId = String(core.getInput("parent_signal_id") || "").trim();

              // If parent signal is provided, resolve missing fields from bus.jsonl.
              let parentSignal = null;
              const busPath = "phosphene/signals/bus.jsonl";
              if (parentSignalId && fs.existsSync(busPath)) {
                const lines = fs.readFileSync(busPath, "utf8").split(/\r?\n/).map(l => l.trim()).filter(Boolean);
                for (const line of lines) {
                  try {
                    const j = JSON.parse(line);
                    if (String(j.signal_id || "") === parentSignalId) {
                      parentSignal = j;
                      break;
                    }
                  } catch (e) {
                    core.warning(`PHOSPHENE: failed to parse bus.jsonl line (parent lookup): ${e.message}`);
                  }
                }
                if (!parentSignal) {
                  core.warning(`PHOSPHENE: parent_signal_id not found in bus.jsonl: ${parentSignalId}`);
                }
              }

              const workId = workIdInput || String(parentSignal?.work_id || "").trim();
              const lane = laneInput || String(parentSignal?.lane || "cerulean").trim().toLowerCase();
              const intent = intentInput || String(parentSignal?.intent || "proposition-development").trim();

              let resolvedWorkId = workId;
              let resolvedParentSignalId = parentSignalId || String(parentSignal?.signal_id || "").trim();

              if (!resolvedWorkId && fs.existsSync(busPath)) {
                // POC fallback: use the most recent merge.research signal in the bus.
                const lines = fs.readFileSync(busPath, "utf8").split(/\r?\n/).map(l => l.trim()).filter(Boolean);
                for (let i = lines.length - 1; i >= 0; i--) {
                  try {
                    const j = JSON.parse(lines[i]);
                    if (j.signal_type === "phosphene.merge.research.v1" && j.work_id) {
                      resolvedWorkId = String(j.work_id || "").trim();
                      resolvedParentSignalId = resolvedParentSignalId || String(j.signal_id || "").trim();
                      break;
                    }
                  } catch (e) {
                    core.warning(`PHOSPHENE: failed to parse bus.jsonl line (fallback): ${e.message}`);
                  }
                }
              }

              if (!resolvedWorkId) {
                core.setFailed("Missing work_id input (and could not infer from parent_signal_id or bus.jsonl).");
                return;
              }

              const dedupeMarker = resolvedParentSignalId
                ? `phosphene-signal-id:${resolvedParentSignalId}`
                : `phosphene-autoscribe:product-marketing:work_id:${resolvedWorkId}`;

              const search = await github.rest.search.issuesAndPullRequests({
                q: `repo:${owner}/${repo} "${dedupeMarker}" in:body type:issue`,
                per_page: 5,
              });
              if (search.data.items.length > 0) {
                core.notice("PHOSPHENE: issue already exists (dedupe hit).");
                return;
              }

              const domainTag = "<product-marketing>";
              const upstreamDomainTag = "<research>";
              const domainSkillPath = ".codex/skills/phosphene/product-marketing/SKILL.md";
              const domainScriptsPath = "phosphene/domains/product-marketing/scripts/";
              const domainDoneScoreCmd = "./phosphene/domains/product-marketing/scripts/product-marketing-domain-done-score.sh --min-score 0";

              const phospheneBlock = [
                "[PHOSPHENE]",
                `lane: ${lane}`,
                "work_type: product-marketing",
                `work_id: ${resolvedWorkId}`,
                `intent: ${intent}`,
                "depends_on:",
                "sequence:",
                `upstream_signal_id: ${resolvedParentSignalId || ""}`.trimEnd(),
                "[/PHOSPHENE]",
              ].join("\n");

              const issueTitle = `PHOSPHENE: <product-marketing> Proposition development for ${resolvedWorkId}`;
              const body = [
                phospheneBlock,
                "",
                template
                  .replaceAll("{{UPSTREAM_PR_NUMBER}}", "N/A")
                  .replaceAll("{{UPSTREAM_PR_TITLE}}", "(merge-signal triggered; no PR context)")
                  .replaceAll("{{UPSTREAM_PR_URL}}", "(n/a)")
                  .replaceAll("{{UPSTREAM_WORK_ID}}", resolvedWorkId)
                  .replaceAll("{{SIGNAL_PATH}}", resolvedParentSignalId ? `phosphene/signals/bus.jsonl#${resolvedParentSignalId}` : "phosphene/signals/bus.jsonl")
                  .replaceAll("{{UPSTREAM_DOMAIN_TAG}}", upstreamDomainTag)
                  .replaceAll("{{DOMAIN_TAG}}", domainTag)
                  .replaceAll("{{DOMAIN_SKILL_PATH}}", domainSkillPath)
                  .replaceAll("{{DOMAIN_SCRIPTS_PATH}}", domainScriptsPath)
                  .replaceAll("{{DOMAIN_DONE_SIGNAL_PATH}}", "phosphene/signals/bus.jsonl (DONE receipt line)")
                  .replaceAll("{{DONE_SCORE_MIN}}", "0")
                  .replaceAll("{{DOMAIN_DONE_SCORE_CMD}}", domainDoneScoreCmd)
                  .replaceAll("{{INTENT}}", intent)
                  .replaceAll("{{POINTERS_BULLETS}}", `- (see upstream research work in repo for ${workId})`)
                  .replaceAll("{{NOTES_BLOCK}}", "")
                  .replaceAll("{{PHOSPHENE_DEDUPE_MARKER}}", dedupeMarker),
              ].join("\n");

              const labels = [
                "phosphene",
                "phosphene:domain:product-marketing",
                "phosphene:ready",
                `phosphene:lane:${lane}`,
              ];

              const issue = await github.rest.issues.create({
                owner,
                repo,
                title: issueTitle,
                body,
                labels,
              });

              core.notice(`PHOSPHENE: created product-marketing issue #${issue.data.number}: ${issue.data.html_url}`);
              return;
            }

            // --- 1) Find signal files changed in this PR
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number,
              per_page: 100,
            });

            const candidateSignalPaths = files
              .map(f => f.filename)
              .filter(p => p.startsWith("phosphene/signals/"));

            if (candidateSignalPaths.length === 0) {
              core.notice("PHOSPHENE: no signal paths in PR (nothing to do).");
              return;
            }

            // --- 2) Load prompt template (parameterized; used as Issue body)
            const templatePath = ".github/prompts/domain_delegation_prompt.md";
            if (!fs.existsSync(templatePath)) {
              throw new Error(`Missing template file: ${templatePath}`);
            }
            const template = fs.readFileSync(templatePath, "utf8");

            // --- 3) Parse signals and create issues
            const created = [];
            for (const signalPath of candidateSignalPaths) {
              // Only accept JSON v1 handoff signals of this exact type.
              if (!signalPath.endsWith(".json")) continue;

              let raw;
              try {
                raw = fs.readFileSync(signalPath, "utf8");
              } catch {
                // If the file changed but doesn't exist in the merge commit, ignore.
                continue;
              }

              let sig;
              try {
                sig = JSON.parse(raw);
              } catch {
                core.notice(`PHOSPHENE: skipping non-JSON signal: ${signalPath}`);
                continue;
              }

              const ok =
                sig?.signal_version === 1 &&
                sig?.signal_type === "phosphene.handoff.research_to_product_marketing.v1" &&
                sig?.from_domain === "research" &&
                sig?.to_domain === "product-marketing";

              if (!ok) continue;

              const workId = sig.work_id || "UNKNOWN";
              const upstreamTitle = pr.title || "(no title)";
              const upstreamUrl = pr.html_url;
              const intent = (sig.intent || "proposition-development").trim();
              const doneScoreMin = (sig.done_score_min != null) ? String(sig.done_score_min) : "80";
              const domainTag = "<product-marketing>";
              const upstreamDomainTag = "<research>";
              const domainSkillPath = ".codex/skills/phosphene/product-marketing/SKILL.md";
              const domainScriptsPath = "phosphene/domains/product-marketing/scripts/";
              const domainDoneSignalPath = "phosphene/signals/bus.jsonl";
              const domainDoneScoreCmd = `./phosphene/domains/product-marketing/scripts/product-marketing-domain-done-score.sh --min-score ${doneScoreMin}`;

              const notesBlock = sig.notes ? `\n## Notes from research\n\n${sig.notes}\n` : "";
              const pointers = Array.isArray(sig.pointers) ? sig.pointers : [];
              const pointersBullets = pointers.length
                ? pointers.map(p => `- \`${p}\``).join("\n")
                : "- (no pointers provided)";

              const signalId = sig.signal_id || "";
              const dedupeMarker = signalId
                ? `phosphene-signal-id:${signalId}`
                : `phosphene-handoff:research->product-marketing;pr=${pull_number};signal=${signalPath};merge=${pr.merge_commit_sha}`;

              // Monotonic consumption: if any other signal declares this one as a parent, skip.
              if (signalId) {
                const walk = (dir) => {
                  const out = [];
                  for (const ent of fs.readdirSync(dir, { withFileTypes: true })) {
                    const p = `${dir}/${ent.name}`;
                    if (ent.isDirectory()) out.push(...walk(p));
                    else if (p.endsWith(".json")) out.push(p);
                  }
                  return out;
                };

                const allSignalJson = walk("phosphene/signals").filter(p => p.endsWith(".json"));
                let hasChild = false;
                for (const p of allSignalJson) {
                  // skip self
                  if (p === signalPath) continue;
                  let other;
                  try {
                    other = JSON.parse(fs.readFileSync(p, "utf8"));
                  } catch {
                    continue;
                  }
                  const parents = Array.isArray(other.parents) ? other.parents : [];
                  if (parents.includes(signalId)) {
                    hasChild = true;
                    break;
                  }
                }
                if (hasChild) {
                  core.notice(`PHOSPHENE: skipping ${signalPath} because it already has child signal(s) (signal_id=${signalId}).`);
                  continue;
                }
              }

              // Dedupe: if an issue already exists with this marker, skip.
              const search = await github.rest.search.issuesAndPullRequests({
                q: `repo:${owner}/${repo} "${dedupeMarker}" in:body type:issue`,
                per_page: 5,
              });
              if (search.data.items.length > 0) {
                core.notice(`PHOSPHENE: issue already exists for ${signalPath} (dedupe hit).`);
                continue;
              }

              const titleSuffix = sig.title || upstreamTitle;
              const issueTitle = `PHOSPHENE: <product-marketing> Proposition development for PR #${pull_number} â€” ${titleSuffix}`;

              const body = template
                .replaceAll("{{UPSTREAM_PR_NUMBER}}", String(pull_number))
                .replaceAll("{{UPSTREAM_PR_TITLE}}", upstreamTitle)
                .replaceAll("{{UPSTREAM_PR_URL}}", upstreamUrl)
                .replaceAll("{{UPSTREAM_WORK_ID}}", workId)
                .replaceAll("{{UPSTREAM_DOMAIN_TAG}}", upstreamDomainTag)
                .replaceAll("{{DOMAIN_TAG}}", domainTag)
                .replaceAll("{{DOMAIN_SKILL_PATH}}", domainSkillPath)
                .replaceAll("{{DOMAIN_SCRIPTS_PATH}}", domainScriptsPath)
                .replaceAll("{{DOMAIN_DONE_SIGNAL_PATH}}", domainDoneSignalPath)
                .replaceAll("{{DONE_SCORE_MIN}}", doneScoreMin)
                .replaceAll("{{DOMAIN_DONE_SCORE_CMD}}", domainDoneScoreCmd)
                .replaceAll("{{INTENT}}", intent)
                .replaceAll("{{SIGNAL_PATH}}", signalPath)
                .replaceAll("{{POINTERS_BULLETS}}", pointersBullets)
                .replaceAll("{{NOTES_BLOCK}}", notesBlock.trim() ? notesBlock : "")
                .replaceAll("{{PHOSPHENE_DEDUPE_MARKER}}", dedupeMarker);

              const extraLabels = Array.isArray(sig.labels) ? sig.labels : [];
              const labels = ["phosphene", "phosphene:domain:product-marketing", "phosphene:handoff", ...extraLabels];

              // Autoscribe policy: this workflow is the only place that may create/update issues.
              const issue = await github.rest.issues.create({
                owner,
                repo,
                title: issueTitle,
                body,
                labels,
              });

              // NOTE (POC topology): autoscribe creates the issue only.
              // Prism is responsible for summoning Codex and emitting the branch-invoked signal.

              created.push({ number: issue.data.number, url: issue.data.html_url, signalPath });
            }

            if (created.length === 0) {
              core.notice("PHOSPHENE: no matching handoff signals found (or all were deduped).");
              return;
            }

            core.notice(`PHOSPHENE: created ${created.length} product-marketing issue(s): ${created.map(i => `#${i.number}`).join(", ")}`);

