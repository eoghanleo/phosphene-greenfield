name: "instrument.gantry.autoscribe.global.enforce_issue_block"

on:
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Issue number to normalize"
        required: true
        type: number
      mode:
        description: "normalize or report"
        required: false
        type: choice
        options: ["normalize", "report"]
        default: "normalize"

  issue_comment:
    types: [created]

permissions:
  contents: read
  issues: write

concurrency:
  group: instrument-autoscribe-enforce-issue-block-${{ github.event.issue.number || inputs.issue_number || github.run_id }}
  cancel-in-progress: true

jobs:
  enforce:
    runs-on: ubuntu-latest
    steps:
      - name: Enforce [PHOSPHENE] block (normalize/report)
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;

            const isBotUser = (u) => {
              const login = (u?.login || "").toLowerCase();
              return Boolean(u?.type === "Bot" || login.endsWith("[bot]") || login === "github-actions");
            };

            const PH_OPEN = "[PHOSPHENE]";
            const PH_CLOSE = "[/PHOSPHENE]";

            const isInformalBlock = (raw) => {
              return /(^|\n)\s*informal\s*(\n|$)/i.test(String(raw || ""));
            };

            const canonicalBlock = (kv) => {
              // Default autoscribe behavior: if we cannot confidently form a "formal" block,
              // mark as INFORMAL. Hopper treats INFORMAL as valid-but-noop (prevents loops).
              if (kv.informal) {
                return [PH_OPEN, "INFORMAL", PH_CLOSE].join("\n");
              }

              const lines = [
                PH_OPEN,
                `lane: ${kv.lane || ""}`.trimEnd(),
                `work_type: ${kv.work_type || ""}`.trimEnd(),
                `intent: ${kv.intent || ""}`.trimEnd(),
                `depends_on: ${kv.depends_on || ""}`.trimEnd(),
                `sequence: ${kv.sequence || ""}`.trimEnd(),
                PH_CLOSE,
              ];
              return lines.join("\n");
            };

            const extractBlock = (text) => {
              const openIdx = text.indexOf(PH_OPEN);
              if (openIdx === -1) return null;
              const closeIdx = text.indexOf(PH_CLOSE, openIdx);
              const endIdx = closeIdx === -1 ? text.length : closeIdx + PH_CLOSE.length;
              return {
                openIdx,
                endIdx,
                raw: text.slice(openIdx, endIdx),
              };
            };

            const parseKvFromBlock = (rawBlock) => {
              const kv = {};
              const lines = rawBlock.split(/\r?\n/);
              for (const line of lines) {
                if (!line.includes(":")) continue;
                if (line.trim() === PH_OPEN || line.trim() === PH_CLOSE) continue;
                const m = line.match(/^\s*([a-zA-Z_]+)\s*:\s*(.*?)\s*$/);
                if (!m) continue;
                const key = m[1].toLowerCase();
                const val = m[2].trim();
                kv[key] = val;
              }
              return kv;
            };

            const laneFromLabels = (labels) => {
              const set = new Set((labels || []).map((s) => String(s).toLowerCase()));
              if (set.has("phosphene:lane:beryl")) return "beryl";
              if (set.has("phosphene:lane:cerulean")) return "cerulean";
              return "";
            };

            const dependsFromBodyLoose = (body) => {
              // Optional helper: preserve an existing "depends_on:" line outside the block.
              const m = body.match(/^\s*(depends-on|depends_on)\s*:\s*(.+?)\s*$/im);
              return m ? m[2].trim() : "";
            };

            // --- Determine invocation
            let issue_number = null;
            let mode = "normalize";
            let invokedBy = "workflow_dispatch";

            if (context.eventName === "workflow_dispatch") {
              issue_number = Number(core.getInput("issue_number", { required: true }));
              mode = (core.getInput("mode") || "normalize").trim().toLowerCase();
            } else if (context.eventName === "issue_comment") {
              invokedBy = "issue_comment";
              const comment = context.payload.comment;
              if (isBotUser(comment?.user)) return;

              const body = String(comment?.body || "");
              const firstLine = body.split(/\r?\n/, 1)[0].trim();
              if (!(/^\/autoscribe\b/i.test(firstLine) || /^@autoscribe\b/i.test(firstLine))) return;

              const arg = firstLine.replace(/^(@autoscribe|\/autoscribe)\b/i, "").trim().toLowerCase();
              // /autoscribe fix | /autoscribe normalize | /autoscribe report
              if (arg === "report") mode = "report";
              else mode = "normalize";

              issue_number = context.payload.issue?.number || null;
            } else {
              return;
            }

            if (!issue_number) return;

            // --- Load issue
            const issueResp = await github.rest.issues.get({ owner, repo, issue_number });
            const issue = issueResp.data;
            const title = String(issue.title || "").trim();
            const body = String(issue.body || "");
            const labels = (issue.labels || [])
              .map((l) => (typeof l === "string" ? l : l?.name))
              .filter(Boolean)
              .map((s) => String(s));

            const existing = extractBlock(body);
            const existingKv = existing ? parseKvFromBlock(existing.raw) : {};
            const existingIsInformal = existing ? isInformalBlock(existing.raw) : false;

            const desired = {
              lane: existingKv.lane || laneFromLabels(labels) || "",
              work_type: existingKv.work_type || "",
              intent: existingKv.intent || title || "",
              depends_on: existingKv.depends_on || dependsFromBodyLoose(body) || "",
              sequence: existingKv.sequence || "",
            };

            // Decide whether we can emit a formal block.
            // Minimal bar for "formal":
            // - lane is beryl|cerulean
            // - work_type is present (non-empty)
            const laneOk = ["beryl", "cerulean"].includes(String(desired.lane || "").toLowerCase());
            const workTypeOk = Boolean(String(desired.work_type || "").trim());
            const informal = existingIsInformal || !(laneOk && workTypeOk);

            const newBlock = canonicalBlock({ ...desired, informal });

            const report = [
              "PHOSPHENE AUTOSCRIBE: enforce [PHOSPHENE] block",
              "",
              `- **Issue**: #${issue_number}`,
              `- **Mode**: \`${mode}\``,
              `- **Existing block**: ${existing ? "YES" : "NO"}`,
              `- **Block classification**: ${informal ? "`INFORMAL`" : "`FORMAL`"}`,
              `- **Lane**: ${desired.lane ? "`" + desired.lane + "`" : "(missing)"}`,
              `- **Work type**: ${desired.work_type ? "`" + desired.work_type + "`" : "(missing)"}`,
              `- **Intent**: ${desired.intent ? desired.intent : "(missing)"}`,
              `- **Depends_on**: ${desired.depends_on ? desired.depends_on : "(none)"}`,
              `- **Sequence**: ${desired.sequence ? desired.sequence : "(none)"}`,
              "",
              "Block preview:",
              "```text",
              newBlock,
              "```",
            ].join("\n");

            if (mode === "report") {
              await github.rest.issues.createComment({ owner, repo, issue_number, body: report });
              return;
            }

            // --- Apply normalization (update issue body)
            let updatedBody = body;
            if (existing) {
              updatedBody = body.slice(0, existing.openIdx) + newBlock + body.slice(existing.endIdx);
            } else {
              // Prepend block for maximum visibility.
              updatedBody = `${newBlock}\n\n${body}`.trimEnd() + "\n";
            }

            if (updatedBody !== body) {
              await github.rest.issues.update({
                owner,
                repo,
                issue_number,
                body: updatedBody,
              });
            }

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number,
              body: report,
            });

